import gradio as gr
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
import time
from tqdm import tqdm
import re
import pandas as pd
from datetime import datetime
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
import matplotlib.pyplot as plt
import tempfile
import os
from openpyxl import load_workbook
from openpyxl.chart import BarChart, Reference
from openpyxl.styles import Font, Alignment, PatternFill
import threading
from collections import deque

# Global variables
driver = None

# API Key Management System
class APIKeyManager:
    def __init__(self, api_keys):
        self.api_keys = deque(api_keys)
        self.current_key = None
        self.failed_keys = set()
        self.lock = threading.Lock()
        self._get_next_key()
    
    def _get_next_key(self):
        """L·∫•y key ti·∫øp theo t·ª´ queue"""
        with self.lock:
            if len(self.api_keys) == 0:
                # Reset queue n·∫øu ƒë√£ h·∫øt key
                self.api_keys = deque([k for k in List_API_KEY if k not in self.failed_keys])
                if len(self.api_keys) == 0:
                    # N·∫øu t·∫•t c·∫£ key ƒë·ªÅu failed, reset l·∫°i to√†n b·ªô
                    self.failed_keys.clear()
                    self.api_keys = deque(List_API_KEY)
            
            if self.api_keys:
                self.current_key = self.api_keys.popleft()
                print(f"üîë ƒêang s·ª≠ d·ª•ng API Key: {self.current_key[:8]}...")
            return self.current_key
    
    def get_current_key(self):
        """L·∫•y key hi·ªán t·∫°i"""
        return self.current_key
    
    def mark_key_failed(self, error_msg=""):
        """ƒê√°nh d·∫•u key hi·ªán t·∫°i l√† failed v√† chuy·ªÉn sang key ti·∫øp theo"""
        with self.lock:
            if self.current_key:
                self.failed_keys.add(self.current_key)
                print(f"‚ùå API Key {self.current_key[:8]}... ƒë√£ failed: {error_msg}")
                self._get_next_key()
                print(f"üîÑ Chuy·ªÉn sang API Key m·ªõi: {self.current_key[:8]}...")
    
    def is_quota_error(self, error):
        """Ki·ªÉm tra xem c√≥ ph·∫£i l·ªói quota kh√¥ng"""
        if isinstance(error, HttpError):
            error_details = str(error)
            quota_indicators = [
                "quotaExceeded", 
                "dailyLimitExceeded",
                "rateLimitExceeded",
                "quota exceeded",
                "daily limit exceeded",
                "rate limit exceeded"
            ]
            return any(indicator.lower() in error_details.lower() for indicator in quota_indicators)
        return False
    
    def execute_with_retry(self, func, *args, **kwargs):
        """Th·ª±c thi function v·ªõi retry khi g·∫∑p l·ªói quota"""
        max_retries = len(List_API_KEY)
        
        for attempt in range(max_retries):
            try:
                current_key = self.get_current_key()
                if not current_key:
                    raise Exception("Kh√¥ng c√≤n API key kh·∫£ d·ª•ng")
                
                # Th√™m api_key v√†o kwargs
                kwargs['api_key'] = current_key
                result = func(*args, **kwargs)
                return result
                
            except Exception as e:
                error_msg = str(e)
                
                # Ki·ªÉm tra n·∫øu l√† l·ªói quota ho·∫∑c key b·ªã ch·∫∑n
                if (self.is_quota_error(e) or 
                    "forbidden" in error_msg.lower() or
                    "invalid" in error_msg.lower() or
                    "disabled" in error_msg.lower()):
                    
                    self.mark_key_failed(error_msg)
                    
                    if attempt == max_retries - 1:
                        raise Exception(f"T·∫•t c·∫£ API key ƒë·ªÅu failed. L·ªói cu·ªëi: {error_msg}")
                    
                    print(f"‚ö†Ô∏è ƒêang th·ª≠ l·∫°i v·ªõi API key m·ªõi... (l·∫ßn {attempt + 1}/{max_retries})")
                    time.sleep(1)  # Delay m·ªôt ch√∫t tr∆∞·ªõc khi retry
                    continue
                else:
                    # L·ªói kh√°c kh√¥ng li√™n quan ƒë·∫øn API key
                    raise e
        
        raise Exception("ƒê√£ h·∫øt s·ªë l·∫ßn th·ª≠")

# Kh·ªüi t·∫°o API Key Manager global
List_API_KEY = [
    'AIzaSyBkbdni528jYjh4Igj5GAvHDV6q4hrR6Kk',
    'AIzaSyBvtOpz_xQTxaCYJGMyT9OIKtu-nlAPdvw',
    'AIzaSyC1EOQa2qAief4m6tWmWCygeqRDmdUKMUQ',
    'AIzaSyBgnX69psjLuqYvX5U_J8MnY2-PEHOLs3c',
    'AIzaSyBLI0ABhHbkTVE0x9ZgDMxwZhwkHuLp6Ec'
]

api_manager = APIKeyManager(List_API_KEY)

def format_number(num):
    """Format s·ªë th√†nh d·∫°ng K, M, B"""
    try:
        num = int(num)
        if num >= 1_000_000_000:
            return f"{num/1_000_000_000:.1f}B"
        elif num >= 1_000_000:
            return f"{num/1_000_000:.1f}M"
        elif num >= 1_000:
            return f"{num/1_000:.1f}K"
        else:
            return str(num)
    except:
        return str(num)

def open_browser():
    """M·ªü tr√¨nh duy·ªát Chrome"""
    global driver
    try:
        if driver is not None:
            try:
                driver.quit()
            except:
                pass
        
        options = Options()
        options.add_argument("--window-size=1200,800")
        options.add_argument("--disable-extensions")
        options.add_argument("--disable-plugins")
        options.add_experimental_option("excludeSwitches", ["enable-automation"])
        options.add_experimental_option('useAutomationExtension', False)
        
        # ƒê·ªÉ browser hi·ªÉn th·ªã (kh√¥ng headless)
        driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)
        driver.get("https://www.youtube.com")
        
        return "‚úÖ ƒê√£ m·ªü tr√¨nh duy·ªát Chrome th√†nh c√¥ng!"
    except Exception as e:
        return f"‚ùå L·ªói khi m·ªü tr√¨nh duy·ªát: {str(e)}"

def close_browser():
    """ƒê√≥ng tr√¨nh duy·ªát"""
    global driver
    try:
        if driver is not None:
            driver.quit()
            driver = None
            return "‚úÖ ƒê√£ ƒë√≥ng tr√¨nh duy·ªát!"
        else:
            return "‚ö†Ô∏è Ch∆∞a c√≥ tr√¨nh duy·ªát n√†o ƒë∆∞·ª£c m·ªü!"
    except Exception as e:
        return f"‚ùå L·ªói khi ƒë√≥ng tr√¨nh duy·ªát: {str(e)}"

def get_channels_urls(hashtag, limit, driver):
    """L·∫•y danh s√°ch URLs c·ªßa c√°c k√™nh t·ª´ hashtag"""
    try:
        # 1. M·ªü YouTube
        driver.get("https://www.youtube.com")
        time.sleep(2)

        # 2. T√¨m ki·∫øm hashtag
        search_box = driver.find_element(By.NAME, "search_query")
        search_box.clear()
        search_box.send_keys(f"{hashtag}")
        search_box.send_keys(Keys.RETURN)
        time.sleep(3)

        # 3. Chuy·ªÉn sang tab "Shorts" (n·∫øu c√≥)
        try:
            shorts_tab = driver.find_element(By.XPATH, "//yt-chip-cloud-chip-renderer//span[contains(text(), 'Shorts')]")
            shorts_tab.click()
            time.sleep(2)
        except Exception:
            pass

        # 4. L·∫•y k√™nh cho t·ªõi khi ƒë·ªß LIMIT
        channels = set()
        last_height = driver.execute_script("return document.documentElement.scrollHeight")
        MAX_SCROLL_ATTEMPTS = 5
        scroll_attempts = 0
        
        while len(channels) < limit and scroll_attempts < MAX_SCROLL_ATTEMPTS:
            shorts = driver.find_elements(By.XPATH, "//a[contains(@href, '/shorts/')]")
            for short in shorts:
                if len(channels) >= limit:
                    break
                try:
                    parent = short.find_element(By.XPATH, "./../../..")
                    selectors = [
                        ".//a[contains(@href, '/@')]",
                        ".//a[contains(@href, '/channel/')]", 
                        ".//a[contains(@href, '/c/')]"
                    ]

                    for selector in selectors:
                        try:
                            channel_elem = parent.find_element(By.XPATH, selector)
                            channel_name = channel_elem.text
                            channel_url = channel_elem.get_attribute("href")
                            channels.add((channel_name, channel_url))
                            break
                        except:
                            continue
                except Exception:
                    continue

            if len(channels) >= limit:
                break

            # Cu·ªôn xu·ªëng
            driver.execute_script("window.scrollTo(0, document.documentElement.scrollHeight);")
            time.sleep(0.5)  
            
            new_height = driver.execute_script("return document.documentElement.scrollHeight")
            if new_height == last_height:
                scroll_attempts += 1
                time.sleep(1)
            else:
                scroll_attempts = 0
            last_height = new_height

        return [url for name, url in list(channels)]
    except Exception as e:
        print(f"L·ªói khi l·∫•y k√™nh: {e}")
        return []

def get_channel_info_from_url(url, api_key):
    """L·∫•y th√¥ng tin k√™nh tr·ª±c ti·∫øp t·ª´ URL YouTube"""
    youtube = build('youtube', 'v3', developerKey=api_key)
    
    # Direct channel ID
    channel_id_match = re.search(r'youtube\.com/channel/([A-Za-z0-9_-]+)', url)
    if channel_id_match:
        channel_id = channel_id_match.group(1)
        request = youtube.channels().list(
            part='snippet,statistics',
            id=channel_id,
            fields='items(id,snippet/title,snippet/publishedAt,statistics/subscriberCount,statistics/videoCount,statistics/viewCount)'
        )
        response = request.execute()
        return response.get('items', [])
    
    # Username format
    handle_match = re.search(r'youtube\.com/@([A-Za-z0-9._-]+)', url)
    if handle_match:
        handle = handle_match.group(1)
        request = youtube.channels().list(
            part='snippet,statistics',
            forHandle=handle,
            fields='items(id,snippet/title,snippet/publishedAt,statistics/subscriberCount,statistics/videoCount,statistics/viewCount)'
        )
        response = request.execute()
        return response.get('items', [])
    
    # Legacy username format
    username_match = re.search(r'youtube\.com/(?:user/|c/)([A-Za-z0-9_-]+)', url)
    if username_match:
        username = username_match.group(1)
        request = youtube.channels().list(
            part='snippet,statistics',
            forUsername=username,
            fields='items(id,snippet/title,snippet/publishedAt,statistics/subscriberCount,statistics/videoCount,statistics/viewCount)'
        )
        response = request.execute()
        return response.get('items', [])
    
    return []

def extract_channel_id_from_url(url):
    """Tr√≠ch xu·∫•t channel_id t·ª´ URL"""
    channel_id_match = re.search(r'youtube\.com/channel/([A-Za-z0-9_-]+)', url)
    if channel_id_match:
        return channel_id_match.group(1)
    return None

def get_channels_info_by_ids(channel_ids, api_key):
    """L·∫•y th√¥ng tin nhi·ªÅu k√™nh b·∫±ng channel_id"""
    youtube = build('youtube', 'v3', developerKey=api_key)
    request = youtube.channels().list(
        part='snippet,statistics',
        id=','.join(channel_ids),
        fields='items(id,snippet/title,snippet/publishedAt,statistics/subscriberCount,statistics/videoCount,statistics/viewCount)'
    )
    response = request.execute()
    return response.get('items', [])

def get_multiple_channels_from_urls_batch(channel_urls):
    """L·∫•y th√¥ng tin nhi·ªÅu k√™nh t·ª´ danh s√°ch URLs v·ªõi API key rotation"""
    global api_manager
    
    all_data = []
    id_url_map = {}
    ids = []
    fallback_urls = []

    # T√°ch channel_id n·∫øu c√≥ th·ªÉ
    for url in channel_urls:
        cid = extract_channel_id_from_url(url)
        if cid:
            ids.append(cid)
            id_url_map[cid] = url
        else:
            fallback_urls.append(url)

    # Chia batch 50 id/l·∫ßn v·ªõi retry mechanism
    for i in range(0, len(ids), 50):
        batch_ids = ids[i:i+50]
        try:
            # S·ª≠ d·ª•ng API manager ƒë·ªÉ execute v·ªõi retry
            items = api_manager.execute_with_retry(get_channels_info_by_ids, batch_ids)
            for item in items:
                all_data.append({
                    'id': item['id'],
                    'title': item['snippet']['title'],
                    'publishedAt': item['snippet']['publishedAt'],
                    'subscriberCount': item['statistics'].get('subscriberCount', 0),
                    'videoCount': item['statistics'].get('videoCount', 0),
                    'viewCount': item['statistics'].get('viewCount', 0),
                    'source_url': id_url_map[item['id']]
                })
        except Exception as e:
            print(f"L·ªói khi l·∫•y batch ids: {e}")

    # V·ªõi c√°c url kh√¥ng c√≥ channel_id
    for url in fallback_urls:
        try:
            # S·ª≠ d·ª•ng API manager ƒë·ªÉ execute v·ªõi retry  
            channel_items = api_manager.execute_with_retry(get_channel_info_from_url, url)
            for item in channel_items:
                all_data.append({
                    'id': item['id'],
                    'title': item['snippet']['title'],
                    'publishedAt': item['snippet']['publishedAt'],
                    'subscriberCount': item['statistics'].get('subscriberCount', 0),
                    'videoCount': item['statistics'].get('videoCount', 0),
                    'viewCount': item['statistics'].get('viewCount', 0),
                    'source_url': url
                })
        except Exception as e:
            print(f"L·ªói khi l·∫•y th√¥ng tin t·ª´ {url}: {e}")

    return pd.DataFrame(all_data)

def plot_subscribers_chart(df):
    """V·∫Ω bi·ªÉu ƒë·ªì subscribers"""
    if df.empty:
        return None
    
    # S·∫Øp x·∫øp theo subscribers gi·∫£m d·∫ßn
    df_sorted = df.sort_values('subscriberCount', ascending=False)
    
    plt.style.use('seaborn-v0_8')
    fig, ax = plt.subplots(figsize=(12, 8))
    
    subscribers = [int(x) for x in df_sorted['subscriberCount']]
    titles = [title[:20] + '...' if len(title) > 20 else title for title in df_sorted['title']]
    
    bars = ax.bar(titles, subscribers, color=['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', 
                                           '#FF9FF3', '#54A0FF', '#5F27CD', '#FD79A8', '#FDCB6E'] * (len(titles)//10+1))
    
    ax.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, p: format_number(x)))
    ax.set_ylabel('Subscribers', fontsize=12, fontweight='bold')
    ax.set_xlabel('Channel', fontsize=12, fontweight='bold')
    ax.set_title('Channels by Subscribers', fontsize=14, fontweight='bold', pad=20)
    plt.xticks(rotation=45, ha='right')
    
    for bar, sub in zip(bars, subscribers):
        height = bar.get_height()
        ax.text(bar.get_x() + bar.get_width()/2., height + height*0.01,
                format_number(sub), ha='center', va='bottom', fontweight='bold')
    
    ax.grid(True, alpha=0.3, axis='y')
    plt.tight_layout()
    
    return fig

def save_to_excel_with_chart(df, hashtag):
    """L∆∞u Excel v·ªõi bi·ªÉu ƒë·ªì"""
    if df.empty:
        return None
    
    # T·∫°o file t·∫°m th·ªùi
    temp_file = tempfile.NamedTemporaryFile(delete=False, suffix='.xlsx')
    file_path = temp_file.name
    temp_file.close()
    
    # Chu·∫©n b·ªã data
    df_export = df.copy()
    
    # Convert to numeric
    df_export['subscriberCount'] = pd.to_numeric(df_export['subscriberCount'], errors='coerce').fillna(0)
    df_export['videoCount'] = pd.to_numeric(df_export['videoCount'], errors='coerce').fillna(0)
    df_export['viewCount'] = pd.to_numeric(df_export['viewCount'], errors='coerce').fillna(0)
    
    # T·∫°o c·ªôt formatted
    df_export['subscriberCount_formatted'] = df_export['subscriberCount'].apply(format_number)
    df_export['videoCount_formatted'] = df_export['videoCount'].apply(format_number)
    df_export['viewCount_formatted'] = df_export['viewCount'].apply(format_number)
    
    # S·∫Øp x·∫øp
    df_export = df_export.sort_values('subscriberCount', ascending=False)
    
    # S·∫Øp x·∫øp columns
    df_export = df_export[['title', 'subscriberCount_formatted', 'videoCount_formatted', 
                          'viewCount_formatted', 'publishedAt', 'subscriberCount', 
                          'videoCount', 'viewCount', 'source_url']]
    
    # L∆∞u DataFrame
    with pd.ExcelWriter(file_path, engine='openpyxl') as writer:
        df_export.to_excel(writer, index=False, sheet_name='Channels')
    
    # Th√™m bi·ªÉu ƒë·ªì v√†o file Excel
    wb = load_workbook(file_path)
    ws = wb.active
    
    # Format header
    header_fill = PatternFill(start_color="366092", end_color="366092", fill_type="solid")
    header_font = Font(color="FFFFFF", bold=True)
    
    for cell in ws[1]:
        cell.fill = header_fill
        cell.font = header_font
        cell.alignment = Alignment(horizontal='center')
    
    # Format numeric columns
    for row in range(2, ws.max_row + 1):
        ws[f'F{row}'].number_format = '#,##0'
        ws[f'G{row}'].number_format = '#,##0'
        ws[f'H{row}'].number_format = '#,##0'
    
    # Auto-fit columns
    column_widths = {
        'A': 30, 'B': 15, 'C': 15, 'D': 15, 'E': 12,
        'F': 15, 'G': 15, 'H': 15, 'I': 40
    }
    
    for col, width in column_widths.items():
        ws.column_dimensions[col].width = width
    
    # T·∫°o bi·ªÉu ƒë·ªì
    max_row = ws.max_row
    chart_start_row = ws.max_row + 3
    
    chart = BarChart()
    chart.title = "All Channels by Subscribers"
    chart.y_axis.title = 'Subscribers'
    chart.x_axis.title = 'Channel'
    chart.width = 25
    chart.height = 15
    chart.style = 10
    
    data = Reference(ws, min_col=6, min_row=1, max_row=max_row)
    cats = Reference(ws, min_col=1, min_row=2, max_row=max_row)
    
    chart.add_data(data, titles_from_data=True)
    chart.set_categories(cats)
    chart.legend = None
    
    ws.add_chart(chart, f"A{chart_start_row}")
    
    # Th√™m title cho section chart
    ws[f'A{chart_start_row-2}'] = "üìä BI·ªÇU ƒê·ªí SO S√ÅNH SUBSCRIBERS"
    ws[f'A{chart_start_row-2}'].font = Font(size=14, bold=True, color="366092")
    
    # ƒê·∫∑t hyperlink cho c·ªôt I
    for row in range(2, ws.max_row + 1):
        cell = ws[f'I{row}']
        url = cell.value
        if url:
            cell.hyperlink = url
            cell.style = "Hyperlink"
    
    wb.save(file_path)
    return file_path

def search_channels(hashtag, limit, progress=gr.Progress()):
    """T√¨m ki·∫øm k√™nh YouTube"""
    global driver
    
    if driver is None:
        gr.Error("Vui l√≤ng m·ªü tr√¨nh duy·ªát tr∆∞·ªõc!")
        return None, None, None, "‚ùå Vui l√≤ng m·ªü tr√¨nh duy·ªát tr∆∞·ªõc!"
    
    if not hashtag:
        gr.Error("Vui l√≤ng nh·∫≠p hashtag!")
        return None, None, None, "‚ùå Vui l√≤ng nh·∫≠p hashtag!"
    
    progress(0.1, desc="ƒêang t√¨m ki·∫øm k√™nh...")
    
    try:
        # L·∫•y danh s√°ch k√™nh
        channel_urls = get_channels_urls(hashtag, int(limit), driver)
        
        if not channel_urls:
            gr.Warning("Kh√¥ng t√¨m th·∫•y k√™nh n√†o!")
            return None, None, None, "‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y k√™nh n√†o!"
        
        progress(0.5, desc=f"ƒê√£ t√¨m th·∫•y {len(channel_urls)} k√™nh, ƒëang l·∫•y th√¥ng tin...")
        
        # L·∫•y th√¥ng tin chi ti·∫øt v·ªõi API key rotation
        df = get_multiple_channels_from_urls_batch(channel_urls)
        
        if df.empty:
            gr.Warning("Kh√¥ng l·∫•y ƒë∆∞·ª£c th√¥ng tin k√™nh!")
            return None, None, None, "‚ö†Ô∏è Kh√¥ng l·∫•y ƒë∆∞·ª£c th√¥ng tin k√™nh!"
        
        progress(0.8, desc="ƒêang t·∫°o bi·ªÉu ƒë·ªì v√† file Excel...")
        
        # Format DataFrame cho hi·ªÉn th·ªã
        df_display = df.copy()
        df_display['subscriberCount'] = df_display['subscriberCount'].apply(format_number)
        df_display['videoCount'] = df_display['videoCount'].apply(format_number)
        df_display['viewCount'] = df_display['viewCount'].apply(format_number)
        df_display['publishedAt'] = pd.to_datetime(df_display['publishedAt']).dt.strftime('%Y-%m-%d')
        
        # ƒê·ªïi t√™n c·ªôt cho d·ªÖ ƒë·ªçc
        df_display = df_display.rename(columns={
            'title': 'T√™n k√™nh',
            'subscriberCount': 'Subscribers',
            'videoCount': 'Videos',
            'viewCount': 'Views',
            'publishedAt': 'Ng√†y t·∫°o',
            'source_url': 'Link'
        })
        
        # S·∫Øp x·∫øp columns
        df_display = df_display[['T√™n k√™nh', 'Subscribers', 'Videos', 'Views', 'Ng√†y t·∫°o', 'Link']]
        
        # V·∫Ω bi·ªÉu ƒë·ªì
        fig = plot_subscribers_chart(df)
        
        # L∆∞u file Excel
        excel_path = save_to_excel_with_chart(df, hashtag)
        
        progress(1.0, desc="Ho√†n th√†nh!")
        
        # Hi·ªÉn th·ªã th√¥ng tin API key ƒë∆∞·ª£c s·ª≠ d·ª•ng
        current_key = api_manager.get_current_key()
        status_msg = f"‚úÖ ƒê√£ t√¨m th·∫•y {len(df)} k√™nh! (API Key: {current_key[:8]}...)"
        
        return df_display, fig, excel_path, status_msg
        
    except Exception as e:
        gr.Error(f"L·ªói: {str(e)}")
        return None, None, None, f"‚ùå L·ªói: {str(e)}"

# T·∫°o giao di·ªán Gradio
with gr.Blocks(title="YouTube Channel Finder by Hashtag", theme=gr.themes.Soft()) as demo:
    gr.Markdown(
        """
        # üé¨ YouTube Channel Finder by Hashtag
        
        T√¨m ki·∫øm c√°c k√™nh YouTube theo hashtag v√† xu·∫•t d·ªØ li·ªáu ra file Excel.
        """
    )
    
    with gr.Row():
        with gr.Column(scale=1):
            gr.Markdown("### üîß ƒêi·ªÅu khi·ªÉn")
            
            # Browser controls
            with gr.Group():
                gr.Markdown("**Tr√¨nh duy·ªát Chrome**")
                browser_status = gr.Textbox(label="Tr·∫°ng th√°i", value="Ch∆∞a m·ªü tr√¨nh duy·ªát", interactive=False)
                with gr.Row():
                    open_btn = gr.Button("üåê M·ªü tr√¨nh duy·ªát", variant="primary")
                    close_btn = gr.Button("‚ùå ƒê√≥ng tr√¨nh duy·ªát", variant="secondary")
            
            # Search controls
            with gr.Group():
                gr.Markdown("**T√¨m ki·∫øm**")
                hashtag_input = gr.Textbox(label="Hashtag", placeholder="Nh·∫≠p hashtag (VD: #food, #music)")
                limit_input = gr.Number(label="S·ªë l∆∞·ª£ng k√™nh", value=20, minimum=1, maximum=100, step=1)
                search_btn = gr.Button("üîç T√¨m ki·∫øm", variant="primary", size="lg")
            
            # Status
            status_text = gr.Textbox(label="K·∫øt qu·∫£", value="", interactive=False)
        
        with gr.Column(scale=3):
            gr.Markdown("### üìä K·∫øt qu·∫£")
            
            # Results tabs
            with gr.Tabs():
                with gr.TabItem("üìã B·∫£ng d·ªØ li·ªáu"):
                    results_df = gr.DataFrame(
                        headers=["T√™n k√™nh", "Subscribers", "Videos", "Views", "Ng√†y t·∫°o", "Link"],
                        datatype=["str", "str", "str", "str", "str", "str"],
                        interactive=False,
                        wrap=True
                    )
                
                with gr.TabItem("üìà Bi·ªÉu ƒë·ªì"):
                    chart_plot = gr.Plot()
            
            # Download button
            with gr.Row():
                excel_file = gr.File(label="üì• T·∫£i file Excel", visible=False)
    
    # Event handlers
    def update_browser_status(msg):
        return msg
    
    open_btn.click(
        fn=lambda: update_browser_status(open_browser()),
        outputs=[browser_status]
    )
    
    close_btn.click(
        fn=lambda: update_browser_status(close_browser()),
        outputs=[browser_status]
    )
    
    search_btn.click(
        fn=search_channels,
        inputs=[hashtag_input, limit_input],
        outputs=[results_df, chart_plot, excel_file, status_text]
    ).then(
        fn=lambda x: gr.update(visible=x is not None),
        inputs=[excel_file],
        outputs=[excel_file]
    )
    
    # Examples
    gr.Examples(
        examples=[
            ["#food", 20],
            ["#music", 30],
            ["#travel", 25],
            ["#gaming", 15],
            ["#football", 20]
        ],
        inputs=[hashtag_input, limit_input],
        label="V√≠ d·ª•"
    )

# Ch·∫°y ·ª©ng d·ª•ng
if __name__ == "__main__":
    demo.launch(
        share=False,
        server_name="0.0.0.0",
        server_port=7860,
        inbrowser=True
    ) 